// 1. Какво е override на функция ?
//  override е предефиниране на функция наследена от базов клас в наследник

#include <iostream>
class Foo
{
public:
	void Chunky()
	{
		std::cout << "Foo::Chunky" << std::endl;
	}

	void Bacon() const
	{
		std::cout << "Foo::Bacon" << std::endl;
	}
};

class Bar : public Foo
{
public:
	void Chunky()
	{
		std::cout << "Bar::Chunky" << std::endl;
	}

	void Bacon()
	{
		std::cout << "Bar::Bacon" << std::endl;
	}
};

// Foo fooObj;
// Bar barObj;
// fooObj.Chunky() // -> "Foo::Chunky"
// barObj.Chunky() // -> "Bar::Chunky"
// const Foo& refToFoo = fooObj;
// const Bar& refToBar = barObj;
// refToFoo.Bacon() // -> "Foo::Bacon"
// refToBar.Bacon() // -> компилационна грешка няма фунцкия Bacon() със константен спецификатор

// 2. Какво е полиморфизъм ?
//    Думата поломорфизъм/поломорфичен/полиморф идва от гръцките думи 'поли'(много) 
//    и 'морф' (форма, структура) и означава многоформенност/многоформен
//       - В материалознанието полиморфизма е способността на твърдите материали да съществуват в повече
//         от една форма или кристална структура (силиция). Например въглерода при достатъчно голямо налягане преподрежда
//         кристалната си структура и от графит става на диамант.
//       - В биологията полиморфизъм е съществуването на морфологично различни индивиди в границите на един вид.
//		   Например при насекомите полиморфизма е свързан с разделянето функциите, при пчелите имат разлчини
//         позиции - търтей, майка и работнички (от един вид са, но имат коренно различни функции)
//       - В обектно ориентираното програмиране под полиморфизъм ще разбираме абсолютно същото - различни обекти (индивид)
//         от един същ базов клас (същият вид) извършват различни действия. Обектите наследяват характеристики от базовият клас
//         (характерни черти на вида), но променят неговата функционалност спрямо тяхната потребност. По друг начин казано
//         полиморфизма представлява свойството на обектите от един същ тип да имат един и същ интерфейс, но с различна реализация -
//         "Един интерфейс, множество от различни реализации". Чрез него постигаме по-голяма абстракция, позволява ни много различни неща
//          да бъдат лесно взаимнозаменяеми и преизползване на код. Наследяването е различно от поломорфизъм!
//          Ние ще разгледаме следните форми на полиморфизъм:
//              1. Статичен полиморфизъм
//              2. Статично свързване на функции
//              3. Динамично свързване на функции
//
// Кои са средствата на С++ за постигане на полиморфизъм ?
//
// 3. Статичен полиморфизъм ?
//    Статичен полиморфизъм ще наричаме презаражденето/overload-ване (предефиниране на базата на броят и типа на аргументите) на функции.
//
//    int sqrt(int number);
//    double sqrt(double number);
//    int pow(int number, int power);
//    int pow(double number, int power);
//
//    В определението за полиморфизъм споменахме че различни обекти от един същ тип могат да има различна реализация.
//    Въпреки че нямаме обекти от даден клас и наследяване, ако мислим за функциите като 'вид' и на различните аргументи
//    като 'индивид', имаме типичното свойство на полиморфизма - разчличните индивиди действат по различни начини.
//    В нашият пример функциите извършват еднакви дейностти, но по различен начин.
//
// 4. Какво е Статично свързване на функции(early binding)
//    В примерът с класовете Foo и Bar видяхме какво е предефиниране на базов метод в някой от неговите наследници.

// 5. Средствата на С++ за полиморфизъм - виртуални функции, final и override
//    Статичен полиморфизъм  и динамичен полиморфизъм
// 6. Виртуални таблици и динамично свързване (dynamic binding)
// 7. Множествено наследяване - кога трябва и не трябва да го ползваме.
//    Виртуално наследяване и какви проблеми решава

class Base1
{
public:
    Base1 (int x)
    {
        value = x;
    }
      
    int getData () const
    {
        return value;
    }
protected:
    int value;
};

class Base2
{
public:
    Base2 (char c)
    { 
        letter = c;
    }

    char getData() const
    {
        return letter;
    }
protected:
    char letter;
};

class Derived: public Base1, public Base2
{
public:
    Derived (int i, char c, float f);
    float getReal () const;

private:
    float real;
};

Derived::Derived(int i, char c, float f) : Base1 (i), Base2 (c)
{
    real = f;
}

float Derived::getReal () const
{
    return real;
}

//Diamond problem
class A
{
public:
    A(int x)
    {
        a = x;
    }
 
    int f() const
    {
        return x;
    }
    
    void print() const
    {
        cout << "A:: a " << a << endl;
    }
    
protected:
    int a;
};
 
class B: public A
{
public:
    B(int x, int y): A(x)
    {
        b = y;
    }
    
    int f() const
    {
        return b;
    }
    
    void print() const
    {
        A::print();
        cout << "B:: b " << b << endl;
    }

protected:
    int b;
};

class C: public A
{
public:
    C(int x, int y): A(x)
    {
        c = y;
    }
    
    int f() const
    {
        return c;
    }
    
    void print() const
    {
        A::print();
        cout << "C:: c " << c << endl;
    }
protected:
    int c;
};

class D: public B, public C
{
public:
    D(int x, int y, int z, int t): B(x, y), C(z, t)
    {
    }
    
    //D(int x, int y, int z): B(x, y), C(x, z)
    //{
    //}
       
    // D(int x, int y, int z, int t): A(x), B(x, y), C(z, t))
    //{
    //}
    
    void print() const
    {
        B::print();
        C::print();
    }
};

// 8. Различни типове преобразувания
//   8.1 Преобразувания в С стил
//   8.2 static_cast<>()
//   8.3 reinterpret_cast<>()
//   8.4 const_cast<>()
//   8.5 dynamic_cast<>()
//   Защо трябва да ги предпочитаме пред преобразувания в С стил
// 9. Какво е абстрактен клас и кога трябва да използваме виртуални деструктори
//    Абстрактен клас ще наричам клас, който има поне чисто виртуална функция.
//    Не може да създваме обекти от абстрактни класове

int main()
{
    return 0;
}
